<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Defense</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            min-height: -webkit-fill-available;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #gameCanvas {
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(0, 255, 136, 0.3);
            cursor: none;
            touch-action: none;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            color: white;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 10;
        }
        
        #startScreen, #gameOverScreen, #winScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 12px;
            color: white;
            text-align: center;
            padding: 15px;
        }
        
        .hidden {
            display: none !important;
        }
        
        h1 {
            font-size: clamp(28px, 8vw, 48px);
            margin-bottom: 15px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d, #6bcb77);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            font-size: clamp(14px, 4vw, 18px);
            color: #aaa;
            margin-bottom: 20px;
            padding: 0 10px;
        }
        
        button {
            background: linear-gradient(45deg, #00d4ff, #00ff88);
            border: none;
            padding: 12px 40px;
            font-size: clamp(18px, 5vw, 24px);
            font-weight: bold;
            color: #1a1a2e;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 10px;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }
        
        .stats {
            font-size: clamp(18px, 5vw, 24px);
            margin: 15px 0;
            color: #ffd93d;
        }
        
        .controls {
            margin-top: 15px;
            font-size: clamp(12px, 3vw, 14px);
            color: #888;
        }
        
        #levelIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.95);
            border-radius: 12px;
            color: white;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <span id="scoreDisplay">Score: 0</span>
            <span id="livesDisplay">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
            <span id="levelDisplay">Level: 1</span>
            <span id="gunsDisplay">Guns: 1</span>
        </div>
        
        <div id="levelIndicator"></div>

        <div id="loadingScreen">
            <h1>Loading...</h1>
            <p class="subtitle">Preparing scales</p>
        </div>
        
        <div id="startScreen" class="hidden">
            <h1>üêç SNAKE DEFENSE üî´</h1>
            <p class="subtitle">The snake is closing in! Destroy it before it reaches the center!</p>
            <button id="startBtn">START GAME</button>
            <p class="controls">
                Aim with mouse/finger ‚Ä¢ Guns auto-fire!<br>
                <span style="color: #44aaff">üî• Blue = Fire Rate Boost</span><br>
                <span style="color: #aa44ff">üî´ Purple = Extra Gun</span>
            </p>
        </div>
        
        <div id="gameOverScreen" class="hidden">
            <h1>üíÄ GAME OVER üíÄ</h1>
            <p class="subtitle">All lives lost!</p>
            <p class="stats">Final Score: <span id="finalScore">0</span></p>
            <p class="stats">Level Reached: <span id="finalLevel">1</span></p>
            <button id="restartBtn">PLAY AGAIN</button>
        </div>
        
        <div id="winScreen" class="hidden">
            <h1>üèÜ VICTORY! üèÜ</h1>
            <p class="stats">You beat all levels!</p>
            <p class="stats">Final Score: <span id="winScore">0</span></p>
            <button id="playAgainBtn">PLAY AGAIN</button>
        </div>
    </div>
    
    <script>
        // Error handler for debugging
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error('Game Error:', msg, 'Line:', lineNo, 'Col:', columnNo);
            return false;
        };
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Offscreen canvas for cached background
        let backgroundCanvas = null;
        let backgroundCtx = null;
        let backgroundNeedsRedraw = true;
        
        // ============== SCALE IMAGES ==============
        // Load the scale images
        const redScaleImg = new Image();
        const yellowScaleImg = new Image();
        const snakeHeadImg = new Image();
        const snakeHeadOpenImg = new Image();
        const yellowTailScaleImg = new Image();
        let imagesLoaded = 0;
        const totalImages = 5;

        function onImageLoad() {
            imagesLoaded++;
            if (imagesLoaded >= totalImages) {
                // All images loaded, hide loading screen and show start screen
                document.getElementById('loadingScreen').classList.add('hidden');
                document.getElementById('startScreen').classList.remove('hidden');
            }
        }

        redScaleImg.onload = onImageLoad;
        yellowScaleImg.onload = onImageLoad;
        snakeHeadImg.onload = onImageLoad;
        snakeHeadOpenImg.onload = onImageLoad;
        yellowTailScaleImg.onload = onImageLoad;

        // Handle image load errors - fall back to embedded data or show error
        redScaleImg.onerror = function() {
            console.error('Failed to load red_scale.png');
            onImageLoad(); // Continue anyway
        };
        yellowScaleImg.onerror = function() {
            console.error('Failed to load yellow_scale.png');
            onImageLoad(); // Continue anyway
        };
        snakeHeadImg.onerror = function() {
            console.error('Failed to load snake_head.png');
            onImageLoad(); // Continue anyway
        };
        snakeHeadOpenImg.onerror = function() {
            console.error('Failed to load snake_head_open.png');
            onImageLoad(); // Continue anyway
        };
        yellowTailScaleImg.onerror = function() {
            console.error('Failed to load yellow_tail_scale.png');
            onImageLoad(); // Continue anyway
        };

        // Set the source paths - these should be in the same folder as the HTML
        redScaleImg.src = 'scale_red.png';
        yellowScaleImg.src = 'scale_yellow.png';
        snakeHeadImg.src = 'snake_head.png';
        snakeHeadOpenImg.src = 'snake_head_open.png';
        yellowTailScaleImg.src = 'yellow_tail_scale.png';
        
        // URL parameters for testing
        const urlParams = new URLSearchParams(window.location.search);
        const startLevel = Math.max(1, Math.min(10, parseInt(urlParams.get('level')) || 1));
        const startGuns = Math.max(0, Math.min(10, parseInt(urlParams.get('guns')) || 0));

        // Game state
        let gameState = 'start';
        let score = 0;
        let level = startLevel;
        const maxLevel = 10;

        // Lives system
        let lives = 3;
        let levelStartState = {
            score: 0,
            fireRateBonus: 0,
            bonusGuns: 0
        };
        
        // Responsive sizing - these get set by resizeCanvas()
        let canvasWidth, canvasHeight;
        let centerX, centerY;
        let scale = 1; // Scale factor for all game elements
        
        // Base dimensions (game is designed for these, then scaled)
        const BASE_WIDTH = 400;
        const BASE_HEIGHT = 600;
        
        // Player input - declare early since resizeCanvas uses these
        let mouseX = 0;
        let mouseY = 0;
        let isPointerDown = false;
        
        function resizeCanvas() {
            // Get available space (accounting for mobile browsers)
            const maxWidth = window.innerWidth;
            const maxHeight = window.innerHeight;

            // Calculate scale to fit while maintaining aspect ratio
            const scaleX = maxWidth / BASE_WIDTH;
            const scaleY = maxHeight / BASE_HEIGHT;
            scale = Math.min(scaleX, scaleY, 1.5); // Cap scale so it doesn't get too big on desktop

            // Set canvas size
            canvasWidth = Math.floor(BASE_WIDTH * scale);
            canvasHeight = Math.floor(BASE_HEIGHT * scale);

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Update center point
            centerX = canvasWidth / 2;
            centerY = canvasHeight / 2 + (30 * scale);

            // Update mouse position to center if not set
            if (mouseX === 0 && mouseY === 0) {
                mouseX = centerX;
                mouseY = centerY - 100 * scale;
            }

            // Resize background canvas and mark for redraw
            if (!backgroundCanvas) {
                backgroundCanvas = document.createElement('canvas');
                backgroundCtx = backgroundCanvas.getContext('2d');
            }
            backgroundCanvas.width = canvasWidth;
            backgroundCanvas.height = canvasHeight;
            backgroundNeedsRedraw = true;
        }
        
        // Initialize canvas size
        resizeCanvas();
        window.addEventListener('resize', () => {
            resizeCanvas();
            // Recalculate snake positions after resize
            if (snakePath.length > 0) {
                updateSnakePositions();
            }
        });
        
        // Snake as a continuous path of points
        let snakePath = [];
        let snakeSegments = [];
        
        // These are now functions that return scaled values
        function getSnakeWidth() { return 36 * scale; }
        function getPlatformRadius() { return 45 * scale; }
        function getSpiralBase() { return 55 * scale; }
        function getSpiralGrowth() { return 12 * scale; } // Reduced from 20 to 12 for tighter coils
        
        let snakeSpeed = 0.15;
        let snakeAngle = 0;
        
        // Guns and bullets
        let guns = [];
        let bullets = [];
        function getBulletSpeed() { return 12 * scale; }
        const fireRate = 18; // Slower fire rate (was 8)
        let globalFireTimer = 0;
        
        // Effects
        let particles = [];
        let damageNumbers = [];

        // Goat bonus system
        let goat = null; // { angle, hp, maxHp, x, y, hitFlash }
        let nextGoatThreshold = 1; // Which goat threshold to spawn next (1 = first goat, 2 = second, etc.)
        let minAngleReached = Infinity; // Track how close snake got to center
        const GOAT_TRIGGER_ANGLE = 4.5; // Base distance for goat spawns (multiples of this)
        const GOAT_SPAWN_OFFSET = 0.70; // How far ahead of snake (toward center) the goat spawns
        const MOUTH_OPEN_DISTANCE = 0.65; // How close to goat before mouth opens (in spiral angle units)
        let snakeMouthOpen = false; // Track if snake mouth should be open
        
        // Spiral constants
        const anglePerPoint = 0.025; // Angular spacing between path points
        
        // Helper: get x,y position on spiral for a given angle
        function getSpiralPosition(angle) {
            const r = getSpiralBase() + angle * getSpiralGrowth();
            return {
                x: centerX + Math.cos(angle) * r,
                y: centerY + Math.sin(angle) * r
            };
        }
        
        // Get radius for a given angle
        function getSpiralRadius(angle) {
            return getSpiralBase() + angle * getSpiralGrowth();
        }
        
        // Update all snake path positions based on current head angle
        function updateSnakePositions() {
            for (let i = 0; i < snakePath.length; i++) {
                const angle = snakeAngle + snakePath[i].offset;
                const pos = getSpiralPosition(angle);
                snakePath[i].x = pos.x;
                snakePath[i].y = pos.y;
            }
        }
        
        // Segment types for bonuses
        const SEGMENT_NORMAL = 'normal';
        const SEGMENT_BONUS_FIRERATE = 'bonus_firerate';
        const SEGMENT_BONUS_GUN = 'bonus_gun';
        
        // Active power-ups
        let fireRateBonus = 0;
        let bonusGuns = 0;
        
        // Initialize snake
        function initSnake() {
            snakePath = [];
            snakeSegments = [];

            // Reset fire rate bonus for new level (guns persist)
            fireRateBonus = 0;

            // Reset goat for new level
            goat = null;
            nextGoatThreshold = 1;
            minAngleReached = Infinity;
            
            // MUCH longer snake - fills entire visible path and extends off-screen
            const pathLength = 800 + level * 100;
            
            // Snake starts close to center - creates urgency!
            // Head starts just outside the platform (a bit further back on level 1)
            const level1Offset = level === 1 ? 15 * scale : 0; // Extra distance for level 1
            const headRadius = getPlatformRadius() + 30 * scale + level1Offset;
            
            // Calculate starting angle for this radius
            snakeAngle = (headRadius - getSpiralBase()) / getSpiralGrowth();
            
            // Build initial spiral path from head (inside) to tail (outside)
            for (let i = 0; i < pathLength; i++) {
                snakePath.push({
                    offset: i * anglePerPoint,
                    x: 0,
                    y: 0
                });
            }
            
            // Calculate initial positions
            updateSnakePositions();
            
            // Create segments with VARIABLE lengths and types
            createVariableSegments();
        }
        
        function calculateGoatHP() {
            const baseHP = 18 + level * 18;
            return Math.floor(baseHP * 1.8) + Math.floor(Math.random() * (level * 6));
        }

        function spawnGoat() {
            if (goat) return; // Already active

            const hp = calculateGoatHP();
            // Goat appears AHEAD of the snake (lower angle = closer to center)
            const goatAngle = snakeAngle - GOAT_SPAWN_OFFSET;
            const pos = getSpiralPosition(goatAngle);

            goat = {
                angle: goatAngle,
                hp: hp,
                maxHp: hp,
                x: pos.x,
                y: pos.y,
                hitFlash: 0
            };

            showPowerUpNotification('GOAT APPEARED!', '#88ff88');
        }

        function createVariableSegments() {
            const baseHP = 18 + level * 18; // Higher HP scaling per level

            // Buffer zone for the head - the first segment starts after this
            // This ensures the head doesn't cover the HP number and segment
            const headBufferPoints = 20; // Number of path points the head covers

            let currentIndex = headBufferPoints; // Start first segment after the head
            let segmentNumber = 0;
            let quickWinCount = 0; // Track how many quick win segments we've created

            while (currentIndex < snakePath.length - 10) {
                let segmentType = SEGMENT_NORMAL;
                let segmentLength;
                let hp;
                let isQuickWin = false; // Track if this segment is a quick win

                if (segmentNumber === 0) {
                    // HEAD SEGMENT: Short but high HP - tough to kill!
                    segmentLength = 15 + Math.floor(Math.random() * 5);
                    // Level 1: Reduced HP for head segment to make it more beatable
                    if (level === 1) {
                        hp = Math.floor(baseHP * 1.2) + level * 10;
                    } else {
                        hp = Math.floor(baseHP * 2) + level * 20;
                    }
                } else if (segmentNumber < 3) {
                    // First few segments near head: Short, moderate-high HP
                    segmentLength = 18 + Math.floor(Math.random() * 8);
                    // Level 1: Reduced HP for early segments
                    if (level === 1) {
                        hp = Math.floor(baseHP * 0.9) + level * 6;
                    } else {
                        hp = Math.floor(baseHP * 1.5) + level * 12;
                    }
                } else {
                    // Rest of snake: Random variety
                    const roll = Math.random();

                    // Level 1: Force extra quick win segments (at least 2 total in first 6 segments)
                    const forceQuickWin = level === 1 && quickWinCount < 2 && segmentNumber >= 3 && segmentNumber <= 5 && (segmentNumber === 5 || roll < 0.5);

                    if (roll < 0.18 || forceQuickWin) {
                        // QUICK WIN: Long segment with LOW HP - satisfying to destroy!
                        segmentLength = 50 + Math.floor(Math.random() * 30);
                        hp = Math.floor(baseHP * 0.4) + Math.floor(Math.random() * 6);
                        isQuickWin = true;
                    } else if (roll < 0.22 && level >= 2) {
                        // BONUS: Fire rate boost segment (glowing blue) - reduced from 6% to 4%
                        segmentType = SEGMENT_BONUS_FIRERATE;
                        segmentLength = 25 + Math.floor(Math.random() * 10);
                        hp = Math.floor(baseHP * 1.0);
                    } else if (roll < 0.17 && level >= 3) {
                        // BONUS: Extra gun segment (glowing purple) - reduced from 4% to 3%
                        segmentType = SEGMENT_BONUS_GUN;
                        segmentLength = 30 + Math.floor(Math.random() * 10);
                        hp = Math.floor(baseHP * 1.2);
                    } else if (roll < 0.30 && level >= 4) {
                        // SUPER HIGH HP: Medium length with 3x long segment HP - tough to kill!
                        // Only spawns on level 4+, ~13% chance when eligible
                        segmentLength = 25 + Math.floor(Math.random() * 15);
                        // Long segment HP formula is: baseHP * 1.8 + random * level * 6
                        // Super high HP = 3x that amount
                        const longHP = Math.floor(baseHP * 1.8) + Math.floor(Math.random() * (level * 6));
                        hp = longHP * 3;
                    } else if (roll < 0.50) {
                        // MEDIUM: Normal length, normal HP
                        segmentLength = 25 + Math.floor(Math.random() * 15);
                        hp = baseHP + Math.floor(Math.random() * (level * 5));
                    } else if (roll < 0.75) {
                        // LONG: Longer segment, proportionally more HP
                        segmentLength = 40 + Math.floor(Math.random() * 25);
                        hp = Math.floor(baseHP * 1.8) + Math.floor(Math.random() * (level * 6));
                    } else {
                        // SHORT: Short segment, moderate HP
                        segmentLength = 15 + Math.floor(Math.random() * 10);
                        hp = Math.floor(baseHP * 0.8) + Math.floor(Math.random() * (level * 3));
                    }
                }
                
                // Make sure we don't exceed path length
                const endIndex = Math.min(currentIndex + segmentLength, snakePath.length);
                
                snakeSegments.push({
                    startIndex: currentIndex,
                    endIndex: endIndex,
                    hp: hp,
                    maxHp: hp,
                    colorBand: segmentNumber % 2,
                    isHead: segmentNumber === 0,
                    segmentType: segmentType,
                    hitFlash: 0 // Timer for hit flash effect (10 frames max)
                });

                // Track quick win segments for level 1 balancing
                if (isQuickWin) {
                    quickWinCount++;
                }

                currentIndex = endIndex;
                segmentNumber++;
            }
        }
        
        function initGuns() {
            guns = [];
            // Base guns from level + any bonus guns earned
            const baseGunCount = Math.min(1 + Math.floor(level / 2), 5);
            const gunCount = Math.min(baseGunCount + bonusGuns, 8); // Max 8 guns
            const gunRadius = 30 * scale;
            
            for (let i = 0; i < gunCount; i++) {
                const angle = (i / gunCount) * Math.PI * 2 - Math.PI / 2;
                guns.push({
                    x: centerX + Math.cos(angle) * gunRadius,
                    y: centerY + Math.sin(angle) * gunRadius,
                    angle: 0,
                    fireTimer: Math.floor(i * fireRate / gunCount)
                });
            }
            
            document.getElementById('gunsDisplay').textContent = `Guns: ${gunCount}`;
        }
        
        // Add a bonus gun (called when bonus segment destroyed)
        function addBonusGun() {
            bonusGuns++;
            // Rebuild guns to add the new one
            initGuns();
            
            // Show notification
            showPowerUpNotification('+1 GUN!', '#aa44ff');
        }
        
        // Boost fire rate (called when bonus segment destroyed)
        function boostFireRate() {
            fireRateBonus += 2; // Reduce fire timer by 2 frames (smaller boost)
            showPowerUpNotification('FIRE RATE UP!', '#44aaff');
        }
        
        // Show power-up notification
        function showPowerUpNotification(text, color) {
            const indicator = document.getElementById('levelIndicator');
            indicator.textContent = text;
            indicator.style.color = color;
            indicator.style.opacity = 1;
            setTimeout(() => {
                indicator.style.opacity = 0;
                indicator.style.color = 'white';
            }, 1000);
        }
        
        function updateSnake() {
            if (snakePath.length === 0) return;
            
            // Move head along the spiral toward center
            snakeAngle -= snakeSpeed * 0.008;
            
            // Update ALL positions based on the spiral formula
            updateSnakePositions();
            
            // Update goat position and check for snake eating it
            if (goat) {
                const goatPos = getSpiralPosition(goat.angle);
                goat.x = goatPos.x;
                goat.y = goatPos.y;

                // Check if snake is close to goat - open mouth when approaching
                const distanceToGoat = snakeAngle - goat.angle;
                snakeMouthOpen = distanceToGoat > 0 && distanceToGoat < MOUTH_OPEN_DISTANCE;

                // Check if snake head reached the goat (snake moves toward lower angles)
                // Trigger when front of head covers the goat (not back of head)
                // The head extends forward, so we check against a larger offset
                if (snakeAngle <= goat.angle + 0.15) {
                    snakeEatsGoat();
                }
            } else {
                // No goat - mouth closed
                snakeMouthOpen = false;
            }

            // Track how close the snake has gotten to the center
            if (snakeAngle < minAngleReached) {
                minAngleReached = snakeAngle;
            }

            // Check if we should spawn a goat:
            // - Snake must have gotten close to center first (below the current threshold)
            // - Then been pushed BACK past the threshold
            // - Each threshold is a multiple of GOAT_TRIGGER_ANGLE (4.5, 9.0, 13.5, etc.)
            const currentThreshold = nextGoatThreshold * GOAT_TRIGGER_ANGLE;
            if (!goat &&
                minAngleReached < currentThreshold &&
                snakeAngle >= currentThreshold) {
                spawnGoat();
                nextGoatThreshold++;
                // Reset minAngleReached so snake must get close again before next goat
                minAngleReached = snakeAngle;
            }

            // Check if head reached center (using scaled values)
            const headRadius = getSpiralRadius(snakeAngle);
            if (headRadius < getPlatformRadius() + 15 * scale) {
                gameOver();
            }
        }
        
        function snakeEatsGoat() {
            if (!goat) return;

            // Calculate segment length for MEDIUM segment
            const segmentLength = 25 + Math.floor(Math.random() * 15);

            // Get the current last point's offset to continue from
            const lastOffset = snakePath.length > 0
                ? snakePath[snakePath.length - 1].offset
                : 0;

            // Add new path points at the END of the snake (tail)
            for (let i = 1; i <= segmentLength; i++) {
                snakePath.push({
                    offset: lastOffset + i * anglePerPoint,
                    x: 0,
                    y: 0
                });
            }

            // Create the new segment at the tail
            const lastSegment = snakeSegments[snakeSegments.length - 1];
            const newSegment = {
                startIndex: lastSegment ? lastSegment.endIndex : 0,
                endIndex: snakePath.length,
                hp: goat.hp, // HP equals goat's remaining HP
                maxHp: goat.hp,
                colorBand: lastSegment ? (lastSegment.colorBand + 1) % 2 : 0,
                isHead: false,
                segmentType: SEGMENT_NORMAL,
                hitFlash: 0
            };

            snakeSegments.push(newSegment);

            // Move snake head FORWARD (toward center) by the segment length
            // This is the key mechanic - eating the goat pulls the snake forward!
            snakeAngle -= segmentLength * anglePerPoint;

            // Update positions
            updateSnakePositions();

            // Show notification
            showPowerUpNotification(`GOAT EATEN! +${goat.hp} HP`, '#88ff88');

            // Particle effect at goat position
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const speed = 5 + Math.random() * 8;
                particles.push({
                    x: goat.x,
                    y: goat.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 40,
                    color: ['#ffffff', '#88ff88', '#ffff88', '#ff8888'][i % 4]
                });
            }

            // Clear the goat
            goat = null;
        }

        function getSegmentAtIndex(pathIndex) {
            for (let i = 0; i < snakeSegments.length; i++) {
                const seg = snakeSegments[i];
                if (pathIndex >= seg.startIndex && pathIndex < seg.endIndex) {
                    return { segment: seg, index: i };
                }
            }

            // If no segment found and we're in the head buffer zone (path indices before first segment),
            // treat it as a hit on the first segment (head segment)
            if (snakeSegments.length > 0 && pathIndex < snakeSegments[0].startIndex) {
                return { segment: snakeSegments[0], index: 0 };
            }

            return null;
        }

        // Find the closest segment to a given world position using spiral geometry
        // Instead of checking all points, we calculate which part of the spiral the bullet is near
        function getClosestSegment(x, y) {
            // Convert x,y to polar coordinates relative to center
            const dx = x - centerX;
            const dy = y - centerY;
            const radius = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            // Calculate which spiral angle this radius corresponds to
            // radius = spiralBase + spiralAngle * spiralGrowth
            // spiralAngle = (radius - spiralBase) / spiralGrowth
            const spiralBase = getSpiralBase();
            const spiralGrowth = getSpiralGrowth();
            const estimatedSpiralAngle = (radius - spiralBase) / spiralGrowth;

            // The spiral wraps, so we need to check multiple possible angles
            // For a given radius, the bullet could be near angle, angle + 2œÄ, angle + 4œÄ, etc.
            let closestSeg = null;
            let closestDist = Infinity;
            let closestIdx = -1;

            // Check a few spiral wraps around the estimated angle
            for (let wrap = -1; wrap <= Math.ceil(estimatedSpiralAngle / (Math.PI * 2)) + 1; wrap++) {
                const testAngle = angle + wrap * Math.PI * 2;
                if (testAngle < 0) continue;

                // Convert this spiral angle to a path index
                // pathIndex ‚âà (testAngle - snakeAngle) / anglePerPoint
                const pathIndex = Math.round((testAngle - snakeAngle) / anglePerPoint);

                // Check a small window around this index (to handle imprecision)
                for (let offset = -3; offset <= 3; offset++) {
                    const idx = pathIndex + offset;
                    if (idx < 0 || idx >= snakePath.length) continue;

                    const p = snakePath[idx];
                    const pdx = x - p.x;
                    const pdy = y - p.y;
                    const distSq = pdx * pdx + pdy * pdy;

                    if (distSq < closestDist) {
                        closestDist = distSq;
                        // Find which segment this index belongs to
                        const segInfo = getSegmentAtIndex(idx);
                        if (segInfo) {
                            closestSeg = segInfo.segment;
                            closestIdx = segInfo.index;
                        }
                    }
                }
            }

            if (closestSeg) {
                return { segment: closestSeg, index: closestIdx, distSq: closestDist };
            }
            return null;
        }
        
        function updateGuns() {
            // All guns aim at mouse position
            const aimAngle = Math.atan2(mouseY - centerY, mouseX - centerX);
            
            for (const gun of guns) {
                gun.angle = aimAngle;
            }
            
            // Fire rate depends on whether holding mouse/touch
            // Holding = fast fire, not holding = slow auto-fire
            globalFireTimer--;
            const fastFireRate = Math.max(6, fireRate - fireRateBonus); // Fast when holding
            const slowFireRate = fastFireRate * 3; // 3x slower when not holding
            const effectiveFireRate = isPointerDown ? fastFireRate : slowFireRate;

            if (globalFireTimer <= 0) {
                globalFireTimer = effectiveFireRate;

                // Each gun fires with slight spread for multi-gun effect
                const gunCount = guns.length;
                guns.forEach((gun, index) => {
                    // Spread guns evenly if multiple
                    const spreadOffset = gunCount > 1
                        ? (index - (gunCount - 1) / 2) * 0.08
                        : 0;
                    fireBullet(gun, spreadOffset);
                });
            }
        }
        
        function fireBullet(gun, spreadOffset = 0) {
            const spread = (Math.random() - 0.5) * 0.1 + spreadOffset;
            const speed = getBulletSpeed();
            bullets.push({
                x: gun.x,
                y: gun.y,
                vx: Math.cos(gun.angle + spread) * speed,
                vy: Math.sin(gun.angle + spread) * speed,
                damage: 1 + Math.floor(level / 3)
            });
        }
        
        // Particle colors for explosions
        const particleColors = {
            0: ['#ff6666', '#ff3333', '#cc0000', '#ffaaaa'], // Red
            1: ['#ffdd66', '#ffcc00', '#cc9900', '#ffeeaa']  // Yellow
        };
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;

                let hit = false;
                const snakeW = getSnakeWidth();
                const hitRadius = snakeW / 2 + 4 * scale;
                const hitRadiusSq = hitRadius * hitRadius;

                // Find the closest segment to this bullet
                const segInfo = getClosestSegment(bullet.x, bullet.y);

                if (segInfo && segInfo.distSq < hitRadiusSq) {
                    segInfo.segment.hp -= bullet.damage;
                    segInfo.segment.hitFlash = 10; // Set flash timer (frames)
                    hit = true;

                    damageNumbers.push({
                        x: bullet.x + (Math.random() - 0.5) * 20,
                        y: bullet.y,
                        value: bullet.damage,
                        life: 25,
                        vy: -3
                    });

                    const colors = particleColors[segInfo.segment.colorBand];
                    for (let k = 0; k < 8; k++) {
                        particles.push({
                            x: bullet.x,
                            y: bullet.y,
                            vx: (Math.random() - 0.5) * 12,
                            vy: (Math.random() - 0.5) * 12,
                            life: 25,
                            color: colors[k % colors.length]
                        });
                    }

                    if (segInfo.segment.hp <= 0) {
                        destroySegment(segInfo.index);
                    }
                }

                // Check goat hit
                if (!hit && goat) {
                    const dx = bullet.x - goat.x;
                    const dy = bullet.y - goat.y;
                    const goatHitRadius = 25 * scale;
                    if (dx * dx + dy * dy < goatHitRadius * goatHitRadius) {
                        goat.hp -= bullet.damage;
                        goat.hitFlash = 10;
                        hit = true;

                        damageNumbers.push({
                            x: bullet.x + (Math.random() - 0.5) * 20,
                            y: bullet.y,
                            value: bullet.damage,
                            life: 25,
                            vy: -3
                        });

                        // Particles
                        for (let k = 0; k < 8; k++) {
                            particles.push({
                                x: bullet.x,
                                y: bullet.y,
                                vx: (Math.random() - 0.5) * 12,
                                vy: (Math.random() - 0.5) * 12,
                                life: 25,
                                color: ['#ffffff', '#cccccc', '#aaaaaa', '#888888'][k % 4]
                            });
                        }

                        // If goat HP reaches 0, destroy it
                        if (goat.hp <= 0) {
                            score += goat.maxHp * 5; // Bonus score for killing goat
                            document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
                            showPowerUpNotification('GOAT DESTROYED!', '#ff8844');

                            // Big particle explosion
                            for (let i = 0; i < 40; i++) {
                                particles.push({
                                    x: goat.x,
                                    y: goat.y,
                                    vx: (Math.random() - 0.5) * 15,
                                    vy: (Math.random() - 0.5) * 15,
                                    life: 40,
                                    color: ['#ffffff', '#ffcc00', '#ff8800', '#ff4400'][i % 4]
                                });
                            }
                            goat = null;
                        }
                    }
                }

                if (hit || bullet.x < 0 || bullet.x > canvasWidth ||
                    bullet.y < 0 || bullet.y > canvasHeight) {
                    bullets.splice(i, 1);
                }
            }
        }
        
        function destroySegment(segIndex) {
            const segment = snakeSegments[segIndex];
            const midIndex = Math.floor((segment.startIndex + segment.endIndex) / 2);
            const midPoint = snakePath[Math.min(midIndex, snakePath.length - 1)];
            
            // Determine particle colors based on segment type
            let colors;
            if (segment.segmentType === SEGMENT_BONUS_FIRERATE) {
                colors = ['#44aaff', '#22ddff', '#0088ff', '#88ddff']; // Blue
            } else if (segment.segmentType === SEGMENT_BONUS_GUN) {
                colors = ['#aa44ff', '#dd22ff', '#8800ff', '#dd88ff']; // Purple
            } else {
                colors = particleColors[segment.colorBand];
            }
            
            if (midPoint) {
                // More particles for bonus segments
                const particleCount = segment.segmentType !== SEGMENT_NORMAL ? 50 : 30;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const speed = 5 + Math.random() * 8;
                    particles.push({
                        x: midPoint.x,
                        y: midPoint.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 40,
                        color: colors[i % colors.length]
                    });
                }
            }
            
            // Apply power-ups from bonus segments
            if (segment.segmentType === SEGMENT_BONUS_FIRERATE) {
                boostFireRate();
            } else if (segment.segmentType === SEGMENT_BONUS_GUN) {
                addBonusGun();
            }
            
            score += segment.maxHp * 10;
            // Bonus score for bonus segments
            if (segment.segmentType !== SEGMENT_NORMAL) {
                score += 500;
            }
            document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
            
            const removeCount = segment.endIndex - segment.startIndex;
            
            // Calculate how much offset we're removing
            const removedOffset = removeCount * anglePerPoint;
            
            // MOVE HEAD BACK: Increase snakeAngle to push the head away from center
            // This is the key mechanic - destroying segments buys you space!
            snakeAngle += removedOffset;
            
            // Adjust offsets of points AFTER the removed segment to maintain continuity
            // Without this, there would be a gap in the spiral
            for (let i = segment.endIndex; i < snakePath.length; i++) {
                snakePath[i].offset -= removedOffset;
            }
            
            // Now remove the points
            snakePath.splice(segment.startIndex, removeCount);
            
            // Update segment indices (segments after the removed one shift down)
            snakeSegments.splice(segIndex, 1);
            for (let i = segIndex; i < snakeSegments.length; i++) {
                snakeSegments[i].startIndex -= removeCount;
                snakeSegments[i].endIndex -= removeCount;
            }
            
            if (snakeSegments.length > 0) {
                snakeSegments[0].isHead = true;
            }
            
            // Recalculate positions immediately so snake looks correct
            updateSnakePositions();
            
            if (snakeSegments.length === 0) {
                levelComplete();
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.93;
                p.vy *= 0.93;
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }

            for (let i = damageNumbers.length - 1; i >= 0; i--) {
                const d = damageNumbers[i];
                d.y += d.vy;
                d.life--;
                if (d.life <= 0) damageNumbers.splice(i, 1);
            }

            // Update hit flash timers for segments
            for (const segment of snakeSegments) {
                if (segment.hitFlash > 0) {
                    segment.hitFlash--;
                }
            }

            // Update goat hit flash
            if (goat && goat.hitFlash > 0) {
                goat.hitFlash--;
            }
        }
        
        // ============== NEW SCALE-BASED SNAKE DRAWING ==============
        
        // Base colors for the solid tube underneath scales
        const baseColors = {
            0: { fill: '#cc2222', edge: '#881111' }, // Red
            1: { fill: '#ccaa00', edge: '#886600' }  // Yellow
        };
        
        // Bonus segment colors
        const bonusColors = {
            'bonus_firerate': { fill: '#2288dd', edge: '#1155aa', glow: '#44aaff' },
            'bonus_gun': { fill: '#8822dd', edge: '#5511aa', glow: '#aa44ff' }
        };
        
        function drawSnakeBody() {
            if (snakePath.length < 4) return;
            
            const snakeW = getSnakeWidth();
            const scaleSize = snakeW * 1.1; // Size of each scale cluster
            const scaleSpacing = scaleSize * 0.55; // How far apart to place scales (overlap them)
            
            // ===== FIRST PASS: Draw solid base tubes for clean edges =====
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            for (let segIdx = snakeSegments.length - 1; segIdx >= 0; segIdx--) {
                const segment = snakeSegments[segIdx];

                // Use bonus colors if it's a bonus segment, otherwise use normal colors
                let colors;
                if (segment.segmentType && bonusColors[segment.segmentType]) {
                    colors = bonusColors[segment.segmentType];
                } else {
                    colors = baseColors[segment.colorBand];
                }

                // For the first segment (head segment), always draw from index 0 to avoid gap
                // This fills the space under the head visually
                const startI = segment.isHead ? 0 : Math.max(0, segment.startIndex);
                const endI = Math.min(snakePath.length - 1, segment.endIndex);

                if (startI >= snakePath.length || endI < 0) continue;
                
                // Draw the solid tube body
                ctx.beginPath();
                ctx.moveTo(snakePath[startI].x, snakePath[startI].y);
                for (let i = startI; i <= endI && i < snakePath.length; i++) {
                    ctx.lineTo(snakePath[i].x, snakePath[i].y);
                }
                
                // Main fill
                ctx.strokeStyle = colors.fill;
                ctx.lineWidth = snakeW;
                ctx.stroke();
                
                // Darker edge outline for depth
                ctx.strokeStyle = colors.edge;
                ctx.lineWidth = snakeW + 4 * scale;
                ctx.globalCompositeOperation = 'destination-over';
                ctx.stroke();
                ctx.globalCompositeOperation = 'source-over';
                
                // Add pulsing glow effect for bonus segments
                if (segment.segmentType && bonusColors[segment.segmentType]) {
                    const glowColor = bonusColors[segment.segmentType].glow;
                    const pulseIntensity = 0.3 + 0.2 * Math.sin(Date.now() / 200);
                    
                    ctx.beginPath();
                    ctx.moveTo(snakePath[startI].x, snakePath[startI].y);
                    for (let i = startI; i <= endI && i < snakePath.length; i++) {
                        ctx.lineTo(snakePath[i].x, snakePath[i].y);
                    }
                    ctx.strokeStyle = glowColor;
                    ctx.lineWidth = snakeW + 12 * scale;
                    ctx.globalAlpha = pulseIntensity;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }
            
            // ===== SECOND PASS: Draw scale images on top (if loaded) =====
            // Draw from head to tail so tail segments overlap head segments at boundaries
            for (let segIdx = 0; segIdx < snakeSegments.length; segIdx++) {
                const segment = snakeSegments[segIdx];

                // Choose the right scale image based on color band
                // For bonus segments, still use alternating colors but with tint
                const scaleImg = segment.colorBand === 0 ? redScaleImg : yellowScaleImg;

                // Only draw scales if image is loaded
                if (scaleImg.complete && scaleImg.naturalWidth > 0) {
                    // For the first segment (head segment), always draw from index 0 to avoid gap
                    const startI = segment.isHead ? 0 : Math.max(0, segment.startIndex);
                    const endI = Math.min(snakePath.length - 1, segment.endIndex);

                    if (startI < snakePath.length && endI >= 0) {
                        // Draw scales along this segment - from start to end (head to tail direction)
                        // This way each scale overlaps the one behind it
                        let distanceTraveled = 0;

                        for (let i = startI; i <= endI; i++) {
                            // Check if we should draw a scale at this point
                            if (i > 0) {
                                const curr = snakePath[i];
                                const prev = snakePath[i - 1];
                                const dx = curr.x - prev.x;
                                const dy = curr.y - prev.y;
                                distanceTraveled += Math.sqrt(dx * dx + dy * dy);
                            }

                            // Only draw scales at regular intervals
                            if (distanceTraveled >= scaleSpacing || i === startI) {
                                distanceTraveled = 0;

                                const point = snakePath[i];

                                // Get direction of snake at this point
                                let angle = 0;
                                if (i > 0 && i < snakePath.length - 1) {
                                    const prev = snakePath[i + 1]; // Behind (toward tail)
                                    const next = snakePath[i - 1]; // Ahead (toward head)
                                    angle = Math.atan2(next.y - prev.y, next.x - prev.x);
                                } else if (i > 0) {
                                    const prev = snakePath[i - 1];
                                    angle = Math.atan2(point.y - prev.y, point.x - prev.x);
                                }

                                // Draw the scale image rotated to match snake direction
                                ctx.save();
                                ctx.translate(point.x, point.y);
                                // Rotate to match snake direction - new scales point right, so just use angle
                                ctx.rotate(angle);

                                // Draw the scale centered on this point
                                ctx.drawImage(
                                    scaleImg,
                                    -scaleSize / 2,
                                    -scaleSize / 2,
                                    scaleSize,
                                    scaleSize
                                );

                                ctx.restore();
                            }
                        }
                    }
                }
            }
            
            // ===== THIRD PASS: Draw hit flash effect on damaged segments =====
            // Flash colors based on segment color band (bright, glowing versions)
            const flashColors = {
                0: { // Red segments - bright glowing red
                    outer: [255, 100, 100],   // Bright red glow
                    inner: [255, 150, 150],   // Lighter red
                    core: [255, 200, 200]     // Near-white red
                },
                1: { // Yellow segments - bright glowing yellow
                    outer: [255, 220, 80],    // Bright yellow glow
                    inner: [255, 240, 150],   // Lighter yellow
                    core: [255, 255, 200]     // Near-white yellow
                }
            };

            for (let segIdx = 0; segIdx < snakeSegments.length; segIdx++) {
                const segment = snakeSegments[segIdx];

                if (segment.hitFlash > 0) {
                    // Shift flash forward to align with visual segment (toward head)
                    const shift = 2;
                    const startI = Math.max(0, segment.startIndex - shift);
                    const endI = Math.min(snakePath.length - 1, segment.endIndex - 1 - shift);

                    if (startI < endI && startI < snakePath.length && endI >= 0) {
                        // Flickering effect - intensity varies rapidly
                        const flickerSpeed = Date.now() / 25;
                        const flicker = 0.5 + 0.5 * Math.sin(flickerSpeed * 12);
                        const baseAlpha = (segment.hitFlash / 10); // Fade out over time
                        const alpha = baseAlpha * (0.6 + flicker * 0.4);

                        // Get flash colors based on segment's color band
                        const colors = flashColors[segment.colorBand];

                        // Draw colored glow overlay
                        ctx.beginPath();
                        ctx.moveTo(snakePath[startI].x, snakePath[startI].y);
                        for (let i = startI; i <= endI && i < snakePath.length; i++) {
                            ctx.lineTo(snakePath[i].x, snakePath[i].y);
                        }

                        // Use butt cap to prevent the line ends from extending past segment boundaries
                        ctx.lineCap = 'butt';
                        ctx.lineJoin = 'round';

                        // Outer glow - colored and intense
                        ctx.strokeStyle = `rgba(${colors.outer[0]}, ${colors.outer[1]}, ${colors.outer[2]}, ${alpha * 0.8})`;
                        ctx.lineWidth = snakeW + 12 * scale;
                        ctx.stroke();

                        // Inner bright flash - lighter colored
                        ctx.strokeStyle = `rgba(${colors.inner[0]}, ${colors.inner[1]}, ${colors.inner[2]}, ${Math.min(1, alpha * 1.3)})`;
                        ctx.lineWidth = snakeW - 4 * scale;
                        ctx.stroke();

                        // Core flash - near-white with color tint for extra intensity
                        ctx.strokeStyle = `rgba(${colors.core[0]}, ${colors.core[1]}, ${colors.core[2]}, ${Math.min(1, alpha * 1.5)})`;
                        ctx.lineWidth = snakeW * 0.5;
                        ctx.stroke();
                    }
                }
            }

            // ===== FOURTH PASS: Draw HP numbers, goat, head, and tail (always) =====

            // Draw goat BEFORE head so snake head appears on top
            if (goat) {
                ctx.save();

                // Glow effect (pulsing)
                const pulseIntensity = 0.4 + 0.3 * Math.sin(Date.now() / 200);
                ctx.shadowColor = '#88ff88';
                ctx.shadowBlur = 20 * scale * pulseIntensity;

                // Draw goat emoji
                ctx.font = `${Math.floor(40 * scale)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('\u{1F410}', goat.x, goat.y);

                // Draw HP below goat
                ctx.shadowBlur = 0;
                ctx.font = `900 ${Math.floor(18 * scale)}px Arial`;
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 3 * scale;
                ctx.strokeText(goat.hp, goat.x, goat.y + 30 * scale);
                ctx.fillStyle = '#88ff88';
                ctx.fillText(goat.hp, goat.x, goat.y + 30 * scale);

                // Hit flash effect
                if (goat.hitFlash > 0) {
                    ctx.globalAlpha = goat.hitFlash / 10;
                    ctx.fillStyle = 'white';
                    ctx.font = `${Math.floor(44 * scale)}px Arial`;
                    ctx.fillText('\u{1F410}', goat.x, goat.y);
                    ctx.globalAlpha = 1;
                }

                ctx.restore();
            }

            for (let segIdx = 0; segIdx < snakeSegments.length; segIdx++) {
                const segment = snakeSegments[segIdx];

                const startI = Math.max(0, segment.startIndex);
                const endI = Math.min(snakePath.length - 1, segment.endIndex);

                if (startI >= snakePath.length || endI < 0) continue;

                // Draw HP number
                const midIdx = Math.floor((segment.startIndex + segment.endIndex) / 2);
                if (midIdx < snakePath.length && midIdx >= 0) {
                    const midPoint = snakePath[midIdx];

                    ctx.fillStyle = 'white';
                    ctx.font = `900 ${Math.floor(20 * scale)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3 * scale;

                    // Show bonus icon above HP for bonus segments
                    if (segment.segmentType === SEGMENT_BONUS_FIRERATE) {
                        ctx.strokeText('üî•', midPoint.x, midPoint.y - 18 * scale);
                        ctx.fillStyle = '#44aaff';
                        ctx.fillText('üî•', midPoint.x, midPoint.y - 18 * scale);
                        ctx.fillStyle = 'white';
                    } else if (segment.segmentType === SEGMENT_BONUS_GUN) {
                        ctx.strokeText('üî´', midPoint.x, midPoint.y - 18 * scale);
                        ctx.fillStyle = '#aa44ff';
                        ctx.fillText('üî´', midPoint.x, midPoint.y - 18 * scale);
                        ctx.fillStyle = 'white';
                    }

                    ctx.strokeText(segment.hp, midPoint.x, midPoint.y);
                    ctx.fillText(segment.hp, midPoint.x, midPoint.y);
                }

                // Draw head - always at index 0 (the actual head position)
                if (segment.isHead) {
                    drawDragonHead(0, segment.colorBand);
                }

                // Draw tail on the last segment - use the actual end of the snake path
                if (segIdx === snakeSegments.length - 1 && snakePath.length > 20) {
                    drawSnakeTail(snakePath.length - 1, segment.colorBand);
                }
            }
        }

        // Dragon head using the snake_head.png image (or snake_head_open.png when near goat)
        function drawDragonHead(startIndex, colorBand) {
            if (startIndex >= snakePath.length) return;

            // Choose which head image to use based on mouth state
            const headImg = snakeMouthOpen ? snakeHeadOpenImg : snakeHeadImg;

            // Skip if image not loaded
            if (!headImg.complete || headImg.naturalWidth === 0) return;

            const headPoint = snakePath[startIndex];
            let headAngle = 0;

            if (startIndex < snakePath.length - 3) {
                const nextPoint = snakePath[startIndex + 3];
                headAngle = Math.atan2(headPoint.y - nextPoint.y, headPoint.x - nextPoint.x);
            }

            // The snake_head.png image faces 180 degrees (straight down), convert to radians
            const imageBaseAngle = 180 * (Math.PI / 180);

            // Rotate 90 degrees counterclockwise to align properly
            const headRotationAdjust = -90 * (Math.PI / 180);

            // Size of the head
            const headSize = getSnakeWidth() * 2.2;

            ctx.save();
            ctx.translate(headPoint.x, headPoint.y);
            // Rotate: subtract the image's base angle so it aligns with snake direction
            ctx.rotate(headAngle - imageBaseAngle + Math.PI + headRotationAdjust);

            // Draw the head image centered on the point, slightly forward
            ctx.drawImage(
                headImg,
                -headSize / 2,
                -headSize / 2,
                headSize,
                headSize
            );

            ctx.restore();
        }
        
        // Snake tail built from progressively smaller scales
        // The tail extends BEYOND the snake body, continuing along the spiral
        function drawSnakeTail(endIndex, colorBand) {
            if (endIndex < 20 || endIndex >= snakePath.length) return;

            // Skip if image not loaded
            if (!yellowTailScaleImg.complete || yellowTailScaleImg.naturalWidth === 0) return;

            const tailScaleCount = 14;
            const snakeW = getSnakeWidth();
            const baseScaleSize = snakeW * 1.1;

            // The tail continues along the spiral BEYOND the current snake path
            // Get the angle offset of the last point in the path
            const lastPathPoint = snakePath[endIndex];
            const lastOffset = lastPathPoint.offset;

            // Build tail positions by continuing along the spiral beyond the snake body
            const tailPositions = [];
            for (let i = 0; i < tailScaleCount; i++) {
                // Each tail scale is further along the spiral (larger offset = further from head)
                const tailOffset = lastOffset + (i + 1) * anglePerPoint * 1.2;
                const tailAngle = snakeAngle + tailOffset;
                const pos = getSpiralPosition(tailAngle);

                // Get angle for rotation by looking at the spiral tangent
                const nextOffset = tailOffset + anglePerPoint;
                const nextAngle = snakeAngle + nextOffset;
                const nextPos = getSpiralPosition(nextAngle);
                const rotation = Math.atan2(nextPos.y - pos.y, nextPos.x - pos.x);

                tailPositions.push({
                    x: pos.x,
                    y: pos.y,
                    angle: rotation
                });
            }

            // Draw from tip toward body (so body-side scales overlap tip-side)
            for (let i = tailScaleCount - 1; i >= 0; i--) {
                const pos = tailPositions[i];

                // First 2 scales (i=0, i=1) are full size, rest taper toward tip
                let sizeMultiplier;
                if (i <= 1) {
                    sizeMultiplier = 1.0;
                } else {
                    // Taper from full size at i=2 down to small at the end
                    const progress = (i - 2) / (tailScaleCount - 3);
                    sizeMultiplier = 1.0 - (progress * 0.8);
                }

                const scaleSize = baseScaleSize * sizeMultiplier;

                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(pos.angle);

                ctx.drawImage(
                    yellowTailScaleImg,
                    -scaleSize / 2,
                    -scaleSize / 2,
                    scaleSize,
                    scaleSize
                );

                ctx.restore();
            }
        }
        
        function drawGuns() {
            const platformR = getPlatformRadius();
            
            // Platform
            ctx.beginPath();
            ctx.arc(centerX, centerY, platformR, 0, Math.PI * 2);
            const platformGrad = ctx.createRadialGradient(centerX - 10 * scale, centerY - 10 * scale, 0, centerX, centerY, platformR);
            platformGrad.addColorStop(0, '#c4a574');
            platformGrad.addColorStop(0.5, '#8b7355');
            platformGrad.addColorStop(1, '#5d4e37');
            ctx.fillStyle = platformGrad;
            ctx.fill();
            ctx.strokeStyle = '#3d2e17';
            ctx.lineWidth = 3 * scale;
            ctx.stroke();
            
            // Platform details
            ctx.beginPath();
            ctx.arc(centerX, centerY, platformR * 0.7, 0, Math.PI * 2);
            ctx.strokeStyle = '#4d3e27';
            ctx.lineWidth = 2 * scale;
            ctx.stroke();
            
            for (const gun of guns) {
                ctx.save();
                ctx.translate(gun.x, gun.y);
                ctx.rotate(gun.angle);
                ctx.scale(scale, scale);
                
                // Gun mount
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#666';
                ctx.fill();
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Gun body
                ctx.fillStyle = '#555';
                ctx.fillRect(-4, -5, 18, 10);
                
                // Barrel
                ctx.fillStyle = '#444';
                ctx.fillRect(10, -3, 16, 6);
                
                // Barrel details
                ctx.fillStyle = '#333';
                ctx.fillRect(22, -4, 5, 8);
                
                // Highlight
                ctx.fillStyle = '#777';
                ctx.fillRect(-2, -4, 14, 2);
                
                ctx.restore();
            }
        }
        
        function drawBullets() {
            const bulletRadius = 4 * scale;
            for (const bullet of bullets) {
                // Bullet trail
                ctx.beginPath();
                ctx.moveTo(bullet.x, bullet.y);
                ctx.lineTo(bullet.x - bullet.vx * 0.5, bullet.y - bullet.vy * 0.5);
                ctx.strokeStyle = 'rgba(255, 200, 0, 0.5)';
                ctx.lineWidth = 3 * scale;
                ctx.stroke();
                
                // Bullet
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bulletRadius, 0, Math.PI * 2);
                const bulletGrad = ctx.createRadialGradient(bullet.x, bullet.y, 0, bullet.x, bullet.y, bulletRadius);
                bulletGrad.addColorStop(0, '#ffffff');
                bulletGrad.addColorStop(0.4, '#ffff00');
                bulletGrad.addColorStop(1, '#ff8800');
                ctx.fillStyle = bulletGrad;
                ctx.fill();
                
                // Glow
                ctx.shadowColor = '#ffaa00';
                ctx.shadowBlur = 10 * scale;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        function drawParticles() {
            for (const p of particles) {
                ctx.globalAlpha = p.life / 40;
                ctx.beginPath();
                ctx.arc(p.x, p.y, (3 + (1 - p.life/40) * 3) * scale, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            
            ctx.font = `bold ${Math.floor(16 * scale)}px Arial`;
            ctx.textAlign = 'center';
            for (const d of damageNumbers) {
                ctx.globalAlpha = d.life / 25;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3 * scale;
                ctx.strokeText(`-${d.value}`, d.x, d.y);
                ctx.fillStyle = '#ffff44';
                ctx.fillText(`-${d.value}`, d.x, d.y);
            }
            ctx.globalAlpha = 1;
        }
        
        function drawCrosshair() {
            // Aiming line from center to cursor
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(mouseX, mouseY);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2 * scale;
            ctx.setLineDash([8 * scale, 8 * scale]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Crosshair at mouse position
            const size = 12 * scale;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 2 * scale;
            
            // Outer circle
            ctx.beginPath();
            ctx.arc(mouseX, mouseY, size, 0, Math.PI * 2);
            ctx.stroke();
            
            // Cross lines
            ctx.beginPath();
            ctx.moveTo(mouseX - size - 4 * scale, mouseY);
            ctx.lineTo(mouseX - size + 6 * scale, mouseY);
            ctx.moveTo(mouseX + size - 6 * scale, mouseY);
            ctx.lineTo(mouseX + size + 4 * scale, mouseY);
            ctx.moveTo(mouseX, mouseY - size - 4 * scale);
            ctx.lineTo(mouseX, mouseY - size + 6 * scale);
            ctx.moveTo(mouseX, mouseY + size - 6 * scale);
            ctx.lineTo(mouseX, mouseY + size + 4 * scale);
            ctx.stroke();
            
            // Center dot
            ctx.beginPath();
            ctx.arc(mouseX, mouseY, 2.5 * scale, 0, Math.PI * 2);
            ctx.fillStyle = '#ff4444';
            ctx.fill();
        }
        
        // Background themes that rotate based on level
        const backgroundThemes = {
            grass: {
                baseColor: '#4a8f15',
                colors: ['#6aaf35', '#5a9f25', '#4a8f15', '#3a7f05'],
                pathColor: 'rgba(139, 115, 85, 0.45)',
                detailColor: 'rgba(255, 255, 255, 0.08)',
                detailType: 'grass' // little grass blades
            },
            desert: {
                baseColor: '#d4a84b',
                colors: ['#e8c874', '#d4a84b', '#c49432', '#a67c28'],
                pathColor: 'rgba(160, 120, 60, 0.4)',
                detailColor: 'rgba(0, 0, 0, 0.05)',
                detailType: 'rocks' // small rocks/pebbles
            },
            water: {
                baseColor: '#2878a8',
                colors: ['#4a9ac8', '#3888b8', '#2878a8', '#1868a0'],
                pathColor: 'rgba(20, 60, 100, 0.35)',
                detailColor: 'rgba(255, 255, 255, 0.15)',
                detailType: 'waves' // wave patterns
            },
            snow: {
                baseColor: '#c8d8e8',
                colors: ['#f0f8ff', '#e0eef8', '#c8d8e8', '#b0c8d8'],
                pathColor: 'rgba(150, 170, 190, 0.4)',
                detailColor: 'rgba(255, 255, 255, 0.3)',
                detailType: 'snowflakes' // snowflake dots
            }
        };

        function getThemeForLevel(lvl) {
            const themeOrder = ['grass', 'desert', 'water', 'snow'];
            const index = (lvl - 1) % themeOrder.length;
            return backgroundThemes[themeOrder[index]];
        }

        function renderBackgroundToCache() {
            const bgCtx = backgroundCtx;
            const theme = getThemeForLevel(level);
            const maxR = Math.max(canvasWidth, canvasHeight);

            // Main background gradient (radial from center)
            const bgGrad = bgCtx.createRadialGradient(centerX, centerY, getSpiralBase(), centerX, centerY, maxR);
            bgGrad.addColorStop(0, theme.colors[0]);
            bgGrad.addColorStop(0.3, theme.colors[1]);
            bgGrad.addColorStop(0.7, theme.colors[2]);
            bgGrad.addColorStop(1, theme.colors[3]);
            bgCtx.fillStyle = bgGrad;
            bgCtx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Draw theme-specific details
            bgCtx.strokeStyle = theme.detailColor;
            bgCtx.fillStyle = theme.detailColor;
            bgCtx.lineWidth = 2 * scale;

            for (let i = 0; i < 40; i++) {
                // Deterministic positions based on index
                const dx = ((i * 137) % 100) / 100 * canvasWidth;
                const dy = ((i * 251) % 100) / 100 * canvasHeight;

                if (theme.detailType === 'grass') {
                    // Grass blades
                    const offsetX = (((i * 73) % 100) / 100 - 0.5) * 8 * scale;
                    const offsetY = (8 + ((i * 197) % 100) / 100 * 8) * scale;
                    bgCtx.beginPath();
                    bgCtx.moveTo(dx, dy);
                    bgCtx.lineTo(dx + offsetX, dy - offsetY);
                    bgCtx.stroke();
                } else if (theme.detailType === 'rocks') {
                    // Small rocks/pebbles
                    const rockSize = (2 + ((i * 89) % 100) / 100 * 4) * scale;
                    bgCtx.beginPath();
                    bgCtx.ellipse(dx, dy, rockSize, rockSize * 0.7, ((i * 31) % 100) / 100 * Math.PI, 0, Math.PI * 2);
                    bgCtx.fill();
                } else if (theme.detailType === 'waves') {
                    // Wave curves
                    const waveLength = (15 + ((i * 61) % 100) / 100 * 20) * scale;
                    bgCtx.beginPath();
                    bgCtx.moveTo(dx - waveLength, dy);
                    bgCtx.quadraticCurveTo(dx - waveLength / 2, dy - 5 * scale, dx, dy);
                    bgCtx.quadraticCurveTo(dx + waveLength / 2, dy + 5 * scale, dx + waveLength, dy);
                    bgCtx.stroke();
                } else if (theme.detailType === 'snowflakes') {
                    // Snowflake dots
                    const snowSize = (1 + ((i * 47) % 100) / 100 * 3) * scale;
                    bgCtx.beginPath();
                    bgCtx.arc(dx, dy, snowSize, 0, Math.PI * 2);
                    bgCtx.fill();
                }
            }

            // Path hint (spiral track)
            bgCtx.strokeStyle = theme.pathColor;
            bgCtx.lineWidth = getSnakeWidth() + 10 * scale;
            bgCtx.lineCap = 'round';
            bgCtx.beginPath();
            for (let a = 0; a < Math.PI * 12; a += 0.1) {
                const r = getSpiralBase() + a * getSpiralGrowth();
                if (r > maxR) break;
                const x = centerX + Math.cos(a) * r;
                const y = centerY + Math.sin(a) * r;
                if (a === 0) bgCtx.moveTo(x, y);
                else bgCtx.lineTo(x, y);
            }
            bgCtx.stroke();

            backgroundNeedsRedraw = false;
        }

        function drawBackground() {
            // Redraw cache if needed (on resize or first frame)
            if (backgroundNeedsRedraw) {
                renderBackgroundToCache();
            }
            // Blit the cached background in one fast operation
            ctx.drawImage(backgroundCanvas, 0, 0);
        }
        
        function gameLoop() {
            if (gameState === 'playing') {
                updateSnake();
                updateGuns();
                updateBullets();
                updateParticles();
            }
            
            drawBackground();
            drawSnakeBody();
            drawGuns();
            drawBullets();
            drawParticles();
            
            if (gameState === 'playing') {
                drawCrosshair();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function startGame() {
            gameState = 'playing';
            score = 0;
            level = startLevel;
            lives = 3;
            // Adjust snake speed based on starting level
            snakeSpeed = 0.15 + (startLevel - 1) * 0.03;
            bullets = [];
            particles = [];
            damageNumbers = [];

            // Reset all power-ups (apply startGuns from URL param)
            bonusGuns = startGuns;
            fireRateBonus = 0;

            // Save level start state
            levelStartState = {
                score: score,
                fireRateBonus: fireRateBonus,
                bonusGuns: bonusGuns
            };

            // Reset goat
            goat = null;
            nextGoatThreshold = 1;
            minAngleReached = Infinity;

            // Redraw background for level theme
            backgroundNeedsRedraw = true;

            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');
            document.getElementById('winScreen').classList.add('hidden');

            initSnake();
            initGuns();
            updateUI();
        }
        
        function levelComplete() {
            if (level >= maxLevel) {
                winGame();
                return;
            }

            level++;
            snakeSpeed += 0.03; // Increased speed scaling per level
            backgroundNeedsRedraw = true; // Redraw background for new theme

            // Save level start state for the new level
            levelStartState = {
                score: score,
                fireRateBonus: fireRateBonus,
                bonusGuns: bonusGuns
            };

            const indicator = document.getElementById('levelIndicator');
            indicator.textContent = `Level ${level}`;
            indicator.style.opacity = 1;

            setTimeout(() => {
                indicator.style.opacity = 0;
                initSnake();
                initGuns();
                updateUI();
            }, 1500);
        }
        
        function gameOver() {
            if (lives > 0) {
                // Lose a life
                lives--;

                if (lives > 0) {
                    // Still have lives - restart the level
                    gameState = 'restarting'; // Pause game during restart

                    // Restore state from level start
                    score = levelStartState.score;
                    fireRateBonus = levelStartState.fireRateBonus;
                    bonusGuns = levelStartState.bonusGuns;

                    // Clear current game objects
                    bullets = [];
                    particles = [];
                    damageNumbers = [];
                    goat = null;
                    nextGoatThreshold = 1;
                    minAngleReached = Infinity;

                    // Show life lost notification
                    const indicator = document.getElementById('levelIndicator');
                    indicator.textContent = `üíî -1 Life! Restarting Level ${level}`;
                    indicator.style.color = '#ff6666';
                    indicator.style.opacity = 1;

                    // Update UI immediately to show lost life
                    updateUI();

                    setTimeout(() => {
                        indicator.style.opacity = 0;
                        indicator.style.color = 'white';
                        initSnake();
                        initGuns();
                        updateUI();
                        gameState = 'playing'; // Resume game
                    }, 1500);
                } else {
                    // No lives left - true game over
                    gameState = 'gameover';
                    document.getElementById('finalScore').textContent = score;
                    document.getElementById('finalLevel').textContent = level;
                    document.getElementById('gameOverScreen').classList.remove('hidden');
                    updateUI();
                }
            }
        }
        
        function winGame() {
            gameState = 'win';
            document.getElementById('winScore').textContent = score;
            document.getElementById('winScreen').classList.remove('hidden');
        }
        
        function updateUI() {
            document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
            document.getElementById('levelDisplay').textContent = `Level: ${level}`;
            // Update lives display with hearts
            document.getElementById('livesDisplay').textContent = '‚ù§Ô∏è'.repeat(lives) + 'üñ§'.repeat(3 - lives);
        }
        
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        document.getElementById('playAgainBtn').addEventListener('click', startGame);
        
        // Helper to convert screen coordinates to canvas coordinates
        function getCanvasCoords(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvasWidth / rect.width;
            const scaleY = canvasHeight / rect.height;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }
        
        // Mouse controls
        canvas.addEventListener('mousemove', (e) => {
            const coords = getCanvasCoords(e.clientX, e.clientY);
            mouseX = coords.x;
            mouseY = coords.y;
            // Treat mouse movement as "active aiming" for fast fire rate (matches mobile touch behavior)
            isPointerDown = true;
        });
        
        canvas.addEventListener('mousedown', (e) => {
            isPointerDown = true;
        });
        
        canvas.addEventListener('mouseup', (e) => {
            isPointerDown = false;
        });
        
        canvas.addEventListener('mouseleave', (e) => {
            isPointerDown = false;
        });
        
        // Touch controls - use passive: false to allow preventDefault
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isPointerDown = true;
            const touch = e.touches[0];
            const coords = getCanvasCoords(touch.clientX, touch.clientY);
            mouseX = coords.x;
            mouseY = coords.y;
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const coords = getCanvasCoords(touch.clientX, touch.clientY);
            mouseX = coords.x;
            mouseY = coords.y;
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            isPointerDown = false;
        });
        
        // Prevent context menu on right-click
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        gameLoop();
    </script>
</body>
</html>
